package fynegui

import (
	"fmt"
	"net"
	"os"
	"sort"
	"strconv"
	"time"

	"fyne.io/fyne"
	"fyne.io/fyne/layout"
	"fyne.io/fyne/widget"
	"github.com/p9c/pod/app/apputil"
	"github.com/p9c/pod/app/save"
	"github.com/p9c/pod/cmd/node"
	"github.com/p9c/pod/cmd/node/con"
	"github.com/p9c/pod/cmd/walletmain"
	"github.com/p9c/pod/pkg/chain/wire"
	"github.com/p9c/pod/pkg/peer"
	"github.com/p9c/pod/pkg/util/cl"
	"github.com/p9c/pod/pkg/wallet"
	"github.com/jinzhu/copier"
	"github.com/urfave/cli"
)

// Settings is the settings page
func Settings(cx *con.Text, a fyne.App) *widget.ScrollContainer {
	var nodeerr, walleterr error
	var nodeSwitch, testnodeSwitch, walletSwitch *widget.Check
	var loglevels []string
	var switchers *widget.Box
	var restartButton *widget.Button
	_, _ = nodeerr, walleterr
	shutdownChan := make(chan struct{})
	for i := range cl.Levels {
		loglevels = append(loglevels, i)
	}
	sort.Strings(loglevels)
	restartButton = widget.NewButton("restart servers", func() {
		n, t, w := nodeSwitch.Checked, testnodeSwitch.Checked, walletSwitch.Checked
		if nodeSwitch.Checked {
			nodeSwitch.SetChecked(false)
		}
		if testnodeSwitch.Checked {
			testnodeSwitch.SetChecked(false)
		}
		if walletSwitch.Checked {
			walletSwitch.SetChecked(false)
		}
		time.Sleep(time.Second)
		if n {
			nodeSwitch.SetChecked(true)
		}
		if t {
			testnodeSwitch.SetChecked(true)
		}
		if w {
			walletSwitch.SetChecked(true)
		}
		restartButton.Disable()
	})
	restartButton.Disable()
	l := widget.NewHBox(
		widget.NewLabelWithStyle("Settings", fyne.TextAlignLeading, fyne.TextStyle{Bold: true}),
		restartButton,
	)
	loglevelswitch := widget.NewRadio(loglevels, func(selected string) {
		fmt.Println("set log level " + selected)
		*cx.Config.LogLevel = selected
		cl.Register.SetAllLevels(*cx.Config.LogLevel)
		save.Pod(cx.Config)
	})
	loglevelswitchbox := widget.NewHBox(
		widget.NewLabel("Logging levels"),
		loglevelswitch,
	)
	loglevelswitch.SetSelected(cl.GlobalLevel)
	nodeSwitch = widget.NewCheck("node running", func(on bool) {
		if on {
			if !cx.Node.Load().(bool) {
				go func() {
					INFO("starting node"}
					cx.NodeKill = make(chan struct{})
					nodeerr = node.Main(cx, shutdownChan, cx.NodeKill)
				}()
				*cx.Config.NodeOff = false
				save.Pod(cx.Config)
				cx.Node.Store(true)
			} else {
				nodeSwitch.SetChecked(false)
			}
		} else {
			if cx.Node.Load().(bool) {
				log <- cl.Inf("stopping node")
				close(cx.NodeKill)
				*cx.Config.NodeOff = true
				save.Pod(cx.Config)
				cx.Node.Store(false)
			} else {
				nodeSwitch.SetChecked(true)
			}
		}
	})
	if cx.ActiveNet.Net == wire.TestNet3 {
		testnodeSwitch = widget.NewCheck("testnode running", func(on bool) {
			if on {
				if !cx.TestNode.Load().(bool) {
					// create a second node so it mines
					cx0 := apputil.GetNewContext("node0", "node0")
					cx0.ActiveNet = cx.ActiveNet
					if err := copier.Copy(cx0.App, cx.App); err != nil {
						panic(err)
					}
					if err := copier.Copy(cx0.Config, cx.Config); err != nil {
						panic(err)
					}
					if err := copier.Copy(cx0.StateCfg, cx.StateCfg); err != nil {
						panic(err)
					}
					// Set config of first instance to point to second
					host, listenport, _ := net.SplitHostPort((*cx.Config.Listeners)[0])
					_, rpcport, _ := net.SplitHostPort((*cx.Config.RPCListeners)[0])
					listenportnumber, _ := strconv.ParseUint(listenport, 10, 32)
					listenportnumber += 100
					listenport0 := fmt.Sprint(listenportnumber)
					rpcportnumber, _ := strconv.ParseUint(rpcport, 10, 32)
					rpcportnumber += 100
					rpcport0 := fmt.Sprint(rpcportnumber)
					*cx.Config.ConnectPeers = cli.StringSlice{net.JoinHostPort(host, listenport0)}
					*cx0.Config.ConnectPeers = cli.StringSlice{net.JoinHostPort(host, listenport)}
					*cx0.Config.Listeners = cli.StringSlice{net.JoinHostPort(host, listenport0)}
					*cx0.Config.RPCListeners = cli.StringSlice{net.JoinHostPort(host, rpcport0)}
					*cx0.Config.Generate = false
					*cx0.Config.GenThreads = 0
					dd := *cx.Config.DataDir + string(os.PathSeparator) + "test"
					*cx0.Config.DataDir = dd
					*cx0.Config.LogDir = dd
					peer.AllowSelfConns = true
					go func() {
						log <- cl.Trace{"starting testnode"}
						cx.TestNodeKill = make(chan struct{})
						err := node.Main(cx0, shutdownChan, cx.TestNodeKill)
						if err != nil {
							// todo: this should pop up an alert
							fmt.Println("error running testnode:", err)
							os.Exit(1)
						}
					}()
					*cx.Config.TestNodeOff = false
					save.Pod(cx.Config)
					cx.TestNode.Store(true)
				} else {
					testnodeSwitch.SetChecked(false)
				}
			} else {
				if cx.TestNode.Load().(bool) {
					INFO("stopping testnode"}
					close(cx.TestNodeKill)
					*cx.Config.TestNodeOff = true
					save.Pod(cx.Config)
					cx.TestNode.Store(false)
				} else {
					testnodeSwitch.SetChecked(true)
				}
			}
		})
		testnodeSwitch.SetChecked(!*cx.Config.TestNodeOff)
	}
	walletSwitch = widget.NewCheck("wallet running", func(on bool) {
		if on {
			if !cx.Wallet.Load().(bool) {
				walletchan := make(chan *wallet.Wallet)
				go func() {
					cx.WalletKill = make(chan struct{})
					walleterr = walletmain.Main(cx.Config, cx.ActiveNet, walletchan, cx.WalletKill)
				}()
				cx.WalletServer = <-walletchan
				*cx.Config.WalletOff = false
				save.Pod(cx.Config)
				// this way we can't stop it before it is saved
				cx.Wallet.Store(true)
			} else {
				walletSwitch.SetChecked(false)
			}
		} else {
			if cx.Wallet.Load().(bool) {
				log <- cl.Inf("stopping wallet")
				close(cx.WalletKill)
				*cx.Config.WalletOff = true
				save.Pod(cx.Config)
				cx.Wallet.Store(false)
			} else {
				walletSwitch.SetChecked(true)
			}
		}
	})
	// This will wait until the wallet has loaded so its existence must be
	// checked before this or it will block indefinitely
	if cx.ActiveNet.Net == wire.TestNet3 {
		switchers = widget.NewVBox(
			nodeSwitch,
			testnodeSwitch,
			walletSwitch,
		)
	} else {
		switchers = widget.NewVBox(
			nodeSwitch,
			walletSwitch,
		)
	}
	nodeSwitch.SetChecked(!*cx.Config.NodeOff)
	walletSwitch.SetChecked(!*cx.Config.WalletOff)

	return widget.NewScrollContainer(
		fyne.NewContainerWithLayout(
			layout.NewBorderLayout(l, nil, nil, nil),
			l,
			widget.NewScrollContainer(
				widget.NewHBox(
					widget.NewVBox(
						widget.NewHBox(
							widget.NewLabel("Node"),
						),
						loglevelswitchbox,
						widget.NewHBox(
							widget.NewLabel("Server status"),
							switchers,
						),
					),
				),
			),
		),
	)
}
